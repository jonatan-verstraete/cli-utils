How to run & connect

Install mitmproxy

(mac) brew install mitmproxy or pip install mitmproxy

(linux) use your package manager or pip install mitmproxy

Start mitmproxy with the addon

mitmproxy -s path/to/cache_proxy.py --listen-port 8080

or use mitmweb for a web UI: mitmweb -s path/to/cache_proxy.py --listen-port 8080

Make your browser use the proxy

Quick dev method: launch Chrome to use proxy directly:

mac: open -a "Google Chrome" --args --proxy-server="http://127.0.0.1:8080"

or use Proxy SwitchyOmega / a PAC file or system proxy settings.

If you use a separate device, set system proxy to 127.0.0.1:8080.

Install mitmproxy CA cert (for HTTPS)

Visit http://mitm.it while proxied and follow the install instructions for your platform (or use mitmproxy docs). This is necessary to intercept HTTPS.

On macOS, you may need to add the cert to Keychain and mark it as trusted for SSL.

Boot your app — capture a “golden” run

Start the app normally while proxied. The addon will save responses for external hosts (non-localhost).

After the app finishes (or after you exercise the flows you care about), subsequent runs will replay saved responses from ~/.cache/mitmproxy-responses.

How to control cache & edge cases

Force live fetch / refresh cache:

Add header x-cache-bypass: 1 to the request (devtools > network > edit and resend or via your dev client).

Or add ?__refresh_cache=1 to the URL.

Exclude additional hosts:

Edit is_local_host() to include domains you never want cached (e.g., api.payments.internal).

Selective caching (only certain paths):

In request()/response() add filtering on flow.request.url or flow.request.path.

Large streaming responses (e.g., big video): skip by checking Content-Length header and not saving if > threshold.

CORS / cookies:

Because mitmproxy replays full headers, you should get the same behavior; however, if your app checks some dynamic auth header or signed cookie, you may need to bypass those endpoints or mock auth differently.

Binary payloads:

The addon stores raw bytes in .body, so images, protobufs, zipped payloads are preserved.

Multiple environments / eviction:

You can write a small script to prune the cache folder by age or disk use.

Quick alternatives / UX upgrades

If you prefer a GUI: use Charles Proxy or Fiddler — they have “map local” / “repeat” features built-in (but are paid or heavier).

If you want the proxy to be truly plug-and-play across many devices, create a PAC file that routes only external hosts via the proxy (leaving localhost direct). I can draft one for you.

If you want to avoid installing CA into the system, you can restrict to HTTP endpoints or test with a development backend that accepts HTTP — but HTTPS interception is more robust.

Caveats & security

Installing a local CA is powerful — don’t leave mitmproxy running on untrusted networks. Treat it like a temporary developer tool.

Keep the cache folder private (it may contain tokens or sensitive responses). Consider masking auth-sensitive endpoints.

This should give you a reliable, controllable man-in-the-middle cache that doesn’t touch your code and catches fetch/axios/XMLHttpRequest/etc. Want me to:

produce a PAC file that proxies external hosts only (so you don’t have to launch Chrome with flags), or

sketch a tiny UI toggle (mitmweb + a simple file that marks endpoints to refresh)?

I’ll draft whichever you’d prefer next — PAC or toggle — and can tighten the addon (expiry, whitelist/blacklist UI, compression) if you want more polish.